local Players = game:GetService("Players")
local VirtualInputManager = game:GetService("VirtualInputManager")
local UserInputService = game:GetService("UserInputService")
local StarterGui = game:GetService("StarterGui")
local LogService = game:GetService("LogService")
local HttpService = game:GetService("HttpService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

local CONFIG = {
    typingSpeed = 0.08,
    minLength = 3,
    maxLength = 15,
    idealLength = 6,
    autoResetTime = 300,
    wordsPerPage = 15,
    learningMode = true,
}

-- Optimized: Use hash set for O(1) lookup
local commonWords = {
    the=1,["and"]=1,a=1,an=1,is=1,it=1,to=1,of=1,
    ["in"]=1,["for"]=1,on=1,with=1,as=1,at=1,by=1,or=1
}

local DICTIONARY_URLS = {
    "https://raw.githubusercontent.com/dwyl/english-words/refs/heads/master/words_dictionary.json",
    "https://raw.githubusercontent.com/first20hours/google-10000-english/master/google-10000-english-usa-no-swears.txt"
}

-- Optimized: Single table with prefix indexing for O(1) lookup
local wordsByPrefix = {}
local allWords = {}
local consoleAutoComplete = false
local usedWords = {}
local lastWordTime = 0
local topWords = {}
local currentPage = 1

local wordStats = {}
local patternSuccess = {}
local totalAttempts = 0
local successfulWords = 0

-- Optimized: Batch storage operations
local pendingSave = false
local lastSaveTime = 0
local SAVE_INTERVAL = 5

local function loadLearningData()
    local success, data = pcall(function()
        return window.storage and window.storage.get("wordSearchStats")
    end)
    if success and data and data.value then
        local decoded = HttpService:JSONDecode(data.value)
        wordStats = decoded.wordStats or {}
        patternSuccess = decoded.patternSuccess or {}
        totalAttempts = decoded.totalAttempts or 0
        successfulWords = decoded.successfulWords or 0
        return true
    end
    return false
end

local function saveLearningData()
    pendingSave = true
end

-- Optimized: Debounced saving
task.spawn(function()
    while task.wait(SAVE_INTERVAL) do
        if pendingSave and tick() - lastSaveTime > SAVE_INTERVAL then
            pcall(function()
                if window.storage then
                    local data = {
                        wordStats = wordStats,
                        patternSuccess = patternSuccess,
                        totalAttempts = totalAttempts,
                        successfulWords = successfulWords,
                        lastUpdate = tick()
                    }
                    window.storage.set("wordSearchStats", HttpService:JSONEncode(data))
                    pendingSave = false
                    lastSaveTime = tick()
                end
            end)
        end
    end
end)

local function recordWordSuccess(word, prefix)
    if not wordStats[word] then
        wordStats[word] = {uses = 0, success = 0, lastUsed = 0}
    end
    local stats = wordStats[word]
    stats.uses = stats.uses + 1
    stats.success = stats.success + 1
    stats.lastUsed = tick()
    
    local patternLen = math.min(3, #prefix)
    local pattern = prefix:sub(1, patternLen)
    if not patternSuccess[pattern] then
        patternSuccess[pattern] = {count = 0}
    end
    patternSuccess[pattern].count = patternSuccess[pattern].count + 1
    
    successfulWords = successfulWords + 1
    totalAttempts = totalAttempts + 1
    
    saveLearningData()
end

-- Optimized: Cached scoring with recency decay
local function getWordScore(word, prefix)
    local score = 0
    local stats = wordStats[word]
    
    if stats then
        score = stats.success * 100
        local recency = tick() - stats.lastUsed
        if recency < 3600 then
            score = score + (50 - recency / 72)
        end
    end
    
    local lenDiff = math.abs(#word - CONFIG.idealLength)
    score = score + (10 - lenDiff * 2)
    
    local patternLen = math.min(3, #prefix)
    local pattern = prefix:sub(1, patternLen)
    if patternSuccess[pattern] then
        score = score + patternSuccess[pattern].count * 10
    end
    
    return score
end

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "MegaWordSearchPro"
screenGui.ResetOnSpawn = false
screenGui.Parent = playerGui

local mainFrame = Instance.new("Frame")
mainFrame.Size = UDim2.new(0, 320, 0, 450)
mainFrame.Position = UDim2.new(0.5, -160, 0.5, -225)
mainFrame.BackgroundColor3 = Color3.fromRGB(15, 15, 15)
mainFrame.BorderColor3 = Color3.fromRGB(0, 255, 255)
mainFrame.BorderSizePixel = 2
mainFrame.Active = true
mainFrame.Draggable = true
mainFrame.Parent = screenGui

local titleBar = Instance.new("TextLabel")
titleBar.Size = UDim2.new(1, 0, 0, 30)
titleBar.BackgroundColor3 = Color3.fromRGB(0, 200, 255)
titleBar.TextColor3 = Color3.fromRGB(0, 0, 0)
titleBar.Font = Enum.Font.GothamBold
titleBar.TextSize = 14
titleBar.Text = "ðŸ§  SMART WORD SEARCH"
titleBar.Parent = mainFrame

local statsBar = Instance.new("TextLabel")
statsBar.Size = UDim2.new(1, -20, 0, 20)
statsBar.Position = UDim2.new(0, 10, 0, 35)
statsBar.BackgroundTransparency = 1
statsBar.TextColor3 = Color3.fromRGB(0, 255, 150)
statsBar.Font = Enum.Font.Gotham
statsBar.TextSize = 11
statsBar.Text = "ðŸ“Š Success: 0/0 (0%)"
statsBar.TextXAlignment = Enum.TextXAlignment.Left
statsBar.Parent = mainFrame

local function updateStatsDisplay()
    local rate = totalAttempts > 0 and math.floor((successfulWords/totalAttempts)*100) or 0
    local learned = 0
    for _ in pairs(wordStats) do learned = learned + 1 end
    statsBar.Text = string.format("ðŸ“Š Success: %d/%d (%d%%) | ðŸ’¾ Learned: %d", 
        successfulWords, totalAttempts, rate, learned)
end

local searchBox = Instance.new("TextBox")
searchBox.Size = UDim2.new(1, -20, 0, 40)
searchBox.Position = UDim2.new(0, 10, 0, 60)
searchBox.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
searchBox.BorderColor3 = Color3.fromRGB(0, 255, 255)
searchBox.BorderSizePixel = 2
searchBox.TextColor3 = Color3.fromRGB(0, 255, 255)
searchBox.PlaceholderText = "Loading..."
searchBox.Font = Enum.Font.GothamBold
searchBox.TextSize = 20
searchBox.ClearTextOnFocus = false
searchBox.TextEditable = true
searchBox.Parent = mainFrame

local modeLabel = Instance.new("TextLabel")
modeLabel.Size = UDim2.new(1, -20, 0, 18)
modeLabel.Position = UDim2.new(0, 10, 0, 105)
modeLabel.BackgroundTransparency = 1
modeLabel.TextColor3 = Color3.fromRGB(255, 200, 0)
modeLabel.Font = Enum.Font.GothamBold
modeLabel.TextSize = 10
modeLabel.Text = "ðŸ§  LEARNING MODE: ON"
modeLabel.TextXAlignment = Enum.TextXAlignment.Left
modeLabel.Parent = mainFrame

local buttonFrame = Instance.new("Frame")
buttonFrame.Size = UDim2.new(1, -20, 0, 35)
buttonFrame.Position = UDim2.new(0, 10, 0, 128)
buttonFrame.BackgroundTransparency = 1
buttonFrame.Parent = mainFrame

local toggleButton = Instance.new("TextButton")
toggleButton.Size = UDim2.new(0.24, 0, 1, 0)
toggleButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
toggleButton.BorderColor3 = Color3.fromRGB(255, 0, 0)
toggleButton.BorderSizePixel = 2
toggleButton.TextColor3 = Color3.fromRGB(255, 0, 0)
toggleButton.Font = Enum.Font.GothamBold
toggleButton.TextSize = 11
toggleButton.Text = "OFF"
toggleButton.Parent = buttonFrame

local learnButton = Instance.new("TextButton")
learnButton.Size = UDim2.new(0.24, 0, 1, 0)
learnButton.Position = UDim2.new(0.25, 0, 0, 0)
learnButton.BackgroundColor3 = Color3.fromRGB(10, 50, 50)
learnButton.BorderColor3 = Color3.fromRGB(0, 255, 200)
learnButton.BorderSizePixel = 2
learnButton.TextColor3 = Color3.fromRGB(0, 255, 200)
learnButton.Font = Enum.Font.GothamBold
learnButton.TextSize = 11
learnButton.Text = "LEARN"
learnButton.Parent = buttonFrame

local trollButton = Instance.new("TextButton")
trollButton.Size = UDim2.new(0.24, 0, 1, 0)
trollButton.Position = UDim2.new(0.5, 0, 0, 0)
trollButton.BackgroundColor3 = Color3.fromRGB(50, 10, 50)
trollButton.BorderColor3 = Color3.fromRGB(255, 0, 255)
trollButton.BorderSizePixel = 2
trollButton.TextColor3 = Color3.fromRGB(255, 0, 255)
trollButton.Font = Enum.Font.GothamBold
trollButton.TextSize = 11
trollButton.Text = "TROLL"
trollButton.Parent = buttonFrame

local resetButton = Instance.new("TextButton")
resetButton.Size = UDim2.new(0.24, 0, 1, 0)
resetButton.Position = UDim2.new(0.75, 0, 0, 0)
resetButton.BackgroundColor3 = Color3.fromRGB(50, 50, 10)
resetButton.BorderColor3 = Color3.fromRGB(255, 255, 0)
resetButton.BorderSizePixel = 2
resetButton.TextColor3 = Color3.fromRGB(255, 255, 0)
resetButton.Font = Enum.Font.GothamBold
resetButton.TextSize = 11
resetButton.Text = "RESET"
resetButton.Parent = buttonFrame

local resultsFrame = Instance.new("ScrollingFrame")
resultsFrame.Size = UDim2.new(1, -20, 1, -225)
resultsFrame.Position = UDim2.new(0, 10, 0, 173)
resultsFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
resultsFrame.BorderColor3 = Color3.fromRGB(0, 255, 150)
resultsFrame.BorderSizePixel = 2
resultsFrame.ScrollBarThickness = 6
resultsFrame.Parent = mainFrame

local listLayout = Instance.new("UIListLayout")
listLayout.SortOrder = Enum.SortOrder.LayoutOrder
listLayout.Padding = UDim.new(0, 2)
listLayout.Parent = resultsFrame

local arrowFrame = Instance.new("Frame")
arrowFrame.Size = UDim2.new(1, -20, 0, 30)
arrowFrame.Position = UDim2.new(0, 10, 1, -35)
arrowFrame.BackgroundTransparency = 1
arrowFrame.Parent = mainFrame

local leftArrow = Instance.new("TextButton")
leftArrow.Size = UDim2.new(0.48, 0, 1, 0)
leftArrow.Text = "<"
leftArrow.Font = Enum.Font.GothamBold
leftArrow.TextSize = 20
leftArrow.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
leftArrow.TextColor3 = Color3.fromRGB(0, 255, 150)
leftArrow.BorderSizePixel = 0
leftArrow.Parent = arrowFrame

local rightArrow = Instance.new("TextButton")
rightArrow.Size = UDim2.new(0.48, 0, 1, 0)
rightArrow.Position = UDim2.new(0.52, 0, 0, 0)
rightArrow.Text = ">"
rightArrow.Font = Enum.Font.GothamBold
rightArrow.TextSize = 20
rightArrow.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
rightArrow.TextColor3 = Color3.fromRGB(0, 255, 150)
rightArrow.BorderSizePixel = 0
rightArrow.Parent = arrowFrame

local function notify(message)
    pcall(function()
        StarterGui:SetCore("SendNotification", {
            Title = "Smart Search",
            Text = message,
            Duration = 2
        })
    end)
end

LogService.MessageOut:Connect(function(message)
    if consoleAutoComplete and message:find("Word:") then
        local letters = message:match("Word:%s*([A-Z]+)")
        if letters then
            lastWordTime = tick()
            notify(letters .. " detected!")
            searchBox.Text = letters
        end
    end
end)

task.spawn(function()
    while task.wait(10) do
        if lastWordTime > 0 and tick() - lastWordTime > CONFIG.autoResetTime then
            usedWords = {}
            lastWordTime = 0
            notify("Auto-reset!")
        end
    end
end)

-- Optimized: Build prefix index during load
local function addWordToIndex(word)
    table.insert(allWords, word)
    for i = CONFIG.minLength, math.min(#word - 1, 4) do
        local prefix = word:sub(1, i)
        if not wordsByPrefix[prefix] then
            wordsByPrefix[prefix] = {}
        end
        table.insert(wordsByPrefix[prefix], word)
    end
end

local function loadFromJSON(content)
    local success, wordsJson = pcall(function()
        return HttpService:JSONDecode(content)
    end)
    if not success then return false end
    for word in pairs(wordsJson) do
        local len = #word
        local lower = word:lower()
        if len >= CONFIG.minLength and len <= CONFIG.maxLength and not commonWords[lower] then
            addWordToIndex(lower)
        end
    end
    return true
end

local function loadFromText(content)
    for word in content:gmatch("[^\r\n]+") do
        local len = #word
        local lower = word:lower()
        if len >= CONFIG.minLength and len <= CONFIG.maxLength and not commonWords[lower] then
            addWordToIndex(lower)
        end
    end
    return #allWords > 0
end

local function loadDictionary()
    notify("Loading dictionary...")
    for _, url in ipairs(DICTIONARY_URLS) do
        local ok, content = pcall(game.HttpGet, game, url)
        if ok then
            local loaded = content:match("^%s*{") and loadFromJSON(content) or loadFromText(content)
            if loaded then
                searchBox.PlaceholderText = "Type word"
                loadLearningData()
                updateStatsDisplay()
                notify("Loaded " .. #allWords .. " words")
                return true
            end
        end
    end
    searchBox.PlaceholderText = "Load failed"
    notify("Failed to load")
    return false
end

local function createWordLabel(text, score)
    local lbl = Instance.new("TextButton")
    lbl.Size = UDim2.new(1, 0, 0, 28)
    lbl.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    lbl.BorderSizePixel = 0
    lbl.TextColor3 = Color3.fromRGB(0, 255, 150)
    lbl.Font = Enum.Font.Gotham
    lbl.TextSize = 15
    
    local displayText = text:upper()
    if CONFIG.learningMode and score > 0 then
        local confidence = math.min(99, math.floor(score / 10))
        displayText = displayText .. string.format(" â­%d%%", confidence)
    end
    
    lbl.Text = displayText
    lbl.Parent = resultsFrame
    return lbl
end

-- Optimized: Fixed auto-type with proper focus and timing
local function autoTypeWord(word, currentInput)
    local remaining = word:sub(#currentInput + 1):upper()
    
    task.spawn(function()
        -- Focus the text box first
        searchBox:CaptureFocus()
        task.wait(0.1)
        
        -- Type each remaining character
        for i = 1, #remaining do
            local char = remaining:sub(i, i)
            local keyCode = Enum.KeyCode[char]
            
            if keyCode then
                VirtualInputManager:SendKeyEvent(true, keyCode, false, game)
                task.wait(CONFIG.typingSpeed)
                VirtualInputManager:SendKeyEvent(false, keyCode, false, game)
                task.wait(0.02)
            end
        end
        
        -- Submit the word
        task.wait(0.15)
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
        task.wait(0.05)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
    end)
end

local function displayPage()
    for _, c in ipairs(resultsFrame:GetChildren()) do
        if c:IsA("TextButton") then c:Destroy() end
    end
    
    local startIdx = (currentPage - 1) * CONFIG.wordsPerPage + 1
    local endIdx = math.min(currentPage * CONFIG.wordsPerPage, #topWords)
    
    for i = startIdx, endIdx do
        local wordData = topWords[i]
        local word = wordData.word
        local score = wordData.score
        local lbl = createWordLabel(word, score)
        
        lbl.MouseButton1Click:Connect(function()
            usedWords[word] = true
            recordWordSuccess(word, searchBox.Text:lower())
            updateStatsDisplay()
            notify("âœ… " .. word)
            autoTypeWord(word, searchBox.Text)
            searchBox.Text = ""
        end)
    end
    
    resultsFrame.CanvasSize = UDim2.new(0, 0, 0, listLayout.AbsoluteContentSize.Y)
end

-- Optimized: Use prefix index for O(1) lookup instead of O(n) scan
local function updateTopWords(input)
    topWords = {}
    input = input:lower()
    
    if input == "" then
        for _, c in ipairs(resultsFrame:GetChildren()) do
            if c:IsA("TextButton") then c:Destroy() end
        end
        return
    end
    
    -- Use prefix index for fast lookup
    local searchPrefix = input:sub(1, math.min(#input, 4))
    local candidates = wordsByPrefix[searchPrefix] or {}
    
    for _, w in ipairs(candidates) do
        if w:sub(1, #input) == input and w ~= input and not usedWords[w] then
            local score = CONFIG.learningMode and getWordScore(w, input) or 0
            table.insert(topWords, {word = w, score = score})
        end
    end
    
    -- Optimized: Single sort with combined criteria
    if CONFIG.learningMode then
        table.sort(topWords, function(a, b)
            if a.score ~= b.score then return a.score > b.score end
            local distA = math.abs(#a.word - CONFIG.idealLength)
            local distB = math.abs(#b.word - CONFIG.idealLength)
            if distA ~= distB then return distA < distB end
            return #a.word == #b.word and a.word < b.word or #a.word < #b.word
        end)
    else
        table.sort(topWords, function(a, b)
            local distA = math.abs(#a.word - CONFIG.idealLength)
            local distB = math.abs(#b.word - CONFIG.idealLength)
            if distA ~= distB then return distA < distB end
            return #a.word == #b.word and a.word < b.word or #a.word < #b.word
        end)
    end
    
    currentPage = 1
    displayPage()
end

toggleButton.MouseButton1Click:Connect(function()
    consoleAutoComplete = not consoleAutoComplete
    toggleButton.Text = consoleAutoComplete and "ON" or "OFF"
    toggleButton.TextColor3 = consoleAutoComplete and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
    toggleButton.BorderColor3 = toggleButton.TextColor3
    notify("Console " .. (consoleAutoComplete and "enabled" or "disabled"))
end)

learnButton.MouseButton1Click:Connect(function()
    CONFIG.learningMode = not CONFIG.learningMode
    if CONFIG.learningMode then
        learnButton.Text = "LEARN"
        learnButton.TextColor3 = Color3.fromRGB(0, 255, 200)
        learnButton.BorderColor3 = Color3.fromRGB(0, 255, 200)
        modeLabel.Text = "ðŸ§  LEARNING MODE: ON"
        notify("ðŸ§  Learning enabled")
    else
        learnButton.Text = "BASIC"
        learnButton.TextColor3 = Color3.fromRGB(150, 150, 150)
        learnButton.BorderColor3 = Color3.fromRGB(100, 100, 100)
        modeLabel.Text = "ðŸ“ BASIC MODE"
        notify("Basic mode")
    end
    updateTopWords(searchBox.Text)
end)

trollButton.MouseButton1Click:Connect(function()
    local input = searchBox.Text:lower()
    if input == "" then
        notify("Type letters first!")
        return
    end
    
    local searchPrefix = input:sub(1, math.min(#input, 4))
    local candidates = wordsByPrefix[searchPrefix] or {}
    local longWords = {}
    
    for _, w in ipairs(candidates) do
        if w:sub(1, #input) == input and not usedWords[w] and #w >= 7 then
            table.insert(longWords, w)
        end
    end
    
    if #longWords == 0 then
        notify("No long words!")
        return
    end
    
    table.sort(longWords, function(a, b) return #a > #b end)
    local trollWord = longWords[1]
    usedWords[trollWord] = true
    recordWordSuccess(trollWord, input)
    updateStatsDisplay()
    notify("ðŸ˜ˆ TROLL: " .. trollWord:upper())
    autoTypeWord(trollWord, searchBox.Text)
    searchBox.Text = ""
end)

resetButton.MouseButton1Click:Connect(function()
    usedWords = {}
    lastWordTime = 0
    notify("Reset complete!")
end)

leftArrow.MouseButton1Click:Connect(function()
    if currentPage > 1 then
        currentPage = currentPage - 1
        displayPage()
    end
end)

rightArrow.MouseButton1Click:Connect(function()
    local maxPage = math.ceil(#topWords / CONFIG.wordsPerPage)
    if currentPage < maxPage then
        currentPage = currentPage + 1
        displayPage()
    end
end)

searchBox.Focused:Connect(function()
    searchBox.Text = ""
end)

-- Optimized: Debounce text updates
local lastUpdate = 0
searchBox:GetPropertyChangedSignal("Text"):Connect(function()
    local now = tick()
    if now - lastUpdate > 0.1 then
        lastUpdate = now
        updateTopWords(searchBox.Text)
    end
end)

task.spawn(function()
    if loadDictionary() then
        notify("ðŸ§  Smart mode ready!")
    end
end)
