print("[MEGA WORD SEARCH PRO - SMART LEARNING] Initializing...")

local Players = game:GetService("Players")
local VirtualInputManager = game:GetService("VirtualInputManager")
local UserInputService = game:GetService("UserInputService")
local StarterGui = game:GetService("StarterGui")
local LogService = game:GetService("LogService")
local HttpService = game:GetService("HttpService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

local CONFIG = {
    typingSpeed = 0.08,
    minLength = 3,
    maxLength = 15,
    idealLength = 6,
    autoResetTime = 300,
    wordsPerPage = 15,
    learningMode = true,
    smartPrediction = true,
    verificationDelay = 2.5,
}

local commonWords = {
    ["the"] = true, ["and"] = true, ["a"] = true, ["an"] = true,
    ["is"] = true, ["it"] = true, ["to"] = true, ["of"] = true,
    ["in"] = true, ["for"] = true, ["on"] = true, ["with"] = true,
    ["as"] = true, ["at"] = true, ["by"] = true, ["or"] = true,
}

local DICTIONARY_URLS = {
    "https://raw.githubusercontent.com/dwyl/english-words/refs/heads/master/words_dictionary.json",
    "https://raw.githubusercontent.com/first20hours/google-10000-english/master/google-10000-english-usa-no-swears.txt"
}

local allWords = {}
local consoleAutoComplete = false
local collectedLetters = {}
local usedWords = {}
local lastWordTime = 0
local topWords = {}
local currentPage = 1
local isTyping = false
local lastTypedWord = nil

local wordStats = {}
local patternSuccess = {}
local totalAttempts = 0
local successfulWords = 0

local function loadLearningData()
    local success, data = pcall(function()
        return window.storage and window.storage.get("wordSearchStats")
    end)
    if success and data and data.value then
        local decoded = HttpService:JSONDecode(data.value)
        wordStats = decoded.wordStats or {}
        patternSuccess = decoded.patternSuccess or {}
        totalAttempts = decoded.totalAttempts or 0
        successfulWords = decoded.successfulWords or 0
        return true
    end
    return false
end

local function saveLearningData()
    pcall(function()
        if window.storage then
            local data = {
                wordStats = wordStats,
                patternSuccess = patternSuccess,
                totalAttempts = totalAttempts,
                successfulWords = successfulWords,
                lastUpdate = tick()
            }
            window.storage.set("wordSearchStats", HttpService:JSONEncode(data))
        end
    end)
end

local function recordWordSuccess(word, prefix)
    if not wordStats[word] then
        wordStats[word] = {uses = 0, success = 0, lastUsed = 0}
    end
    wordStats[word].uses = wordStats[word].uses + 1
    wordStats[word].success = wordStats[word].success + 1
    wordStats[word].lastUsed = tick()
    
    local pattern = prefix .. string.rep("_", #word - #prefix)
    if not patternSuccess[pattern] then
        patternSuccess[pattern] = {count = 0, words = {}}
    end
    patternSuccess[pattern].count = patternSuccess[pattern].count + 1
    table.insert(patternSuccess[pattern].words, word)
    
    successfulWords = successfulWords + 1
    totalAttempts = totalAttempts + 1
    
    saveLearningData()
end

local function recordWordFailure(word)
    if not wordStats[word] then
        wordStats[word] = {uses = 0, success = 0, lastUsed = 0}
    end
    wordStats[word].uses = wordStats[word].uses + 1
    totalAttempts = totalAttempts + 1
    saveLearningData()
end

local function getWordScore(word, prefix)
    local score = 0
    
    if wordStats[word] then
        score = score + (wordStats[word].success * 100)
        if wordStats[word].uses > 0 then
            local successRate = wordStats[word].success / wordStats[word].uses
            score = score - ((1 - successRate) * 50)
        end
        local recency = tick() - (wordStats[word].lastUsed or 0)
        if recency < 3600 then
            score = score + 50
        end
    end
    
    local lenDiff = math.abs(#word - CONFIG.idealLength)
    score = score + (10 - lenDiff * 2)
    
    local pattern = prefix .. string.rep("_", #word - #prefix)
    if patternSuccess[pattern] then
        score = score + (patternSuccess[pattern].count * 10)
    end
    
    return score
end

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "MegaWordSearchPro"
screenGui.ResetOnSpawn = false
screenGui.Parent = playerGui

local dragHandle = Instance.new("TextButton")
dragHandle.Size = UDim2.new(0, 320, 0, 420)
dragHandle.Position = UDim2.new(0.5, -160, 0.5, -210)
dragHandle.BackgroundTransparency = 1
dragHandle.Text = ""
dragHandle.Active = true
dragHandle.Parent = screenGui

local mainFrame = Instance.new("Frame")
mainFrame.Size = UDim2.new(1, 0, 1, 0)
mainFrame.Position = UDim2.new(0, 0, 0, 0)
mainFrame.BackgroundColor3 = Color3.fromRGB(15, 15, 15)
mainFrame.BorderColor3 = Color3.fromRGB(0, 255, 255)
mainFrame.BorderSizePixel = 2
mainFrame.Parent = dragHandle

local isDragging = false
local dragStart = nil
local startPos = nil

dragHandle.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        isDragging = true
        dragStart = input.Position
        startPos = dragHandle.Position
    end
end)

dragHandle.InputChanged:Connect(function(input)
    if isDragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
        local delta = input.Position - dragStart
        dragHandle.Position = UDim2.new(
            startPos.X.Scale, startPos.X.Offset + delta.X,
            startPos.Y.Scale, startPos.Y.Offset + delta.Y
        )
    end
end)

dragHandle.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        isDragging = false
    end
end)

local statsBar = Instance.new("TextLabel")
statsBar.Size = UDim2.new(1, -20, 0, 20)
statsBar.Position = UDim2.new(0, 10, 0, 5)
statsBar.BackgroundTransparency = 1
statsBar.TextColor3 = Color3.fromRGB(0, 255, 150)
statsBar.Font = Enum.Font.Gotham
statsBar.TextSize = 11
statsBar.Text = "üìä Success: 0/0 (0%)"
statsBar.TextXAlignment = Enum.TextXAlignment.Left
statsBar.Parent = mainFrame

local function updateStatsDisplay()
    local rate = totalAttempts > 0 and math.floor((successfulWords/totalAttempts)*100) or 0
    statsBar.Text = string.format("üìä Success: %d/%d (%d%%) | üíæ Learned: %d words", 
        successfulWords, totalAttempts, rate, #wordStats)
end

local searchBox = Instance.new("TextBox")
searchBox.Size = UDim2.new(1, -20, 0, 40)
searchBox.Position = UDim2.new(0, 10, 0, 30)
searchBox.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
searchBox.BorderColor3 = Color3.fromRGB(0, 255, 255)
searchBox.BorderSizePixel = 2
searchBox.TextColor3 = Color3.fromRGB(0, 255, 255)
searchBox.PlaceholderText = "Loading..."
searchBox.Font = Enum.Font.GothamBold
searchBox.TextSize = 20
searchBox.ClearTextOnFocus = false
searchBox.TextEditable = true
searchBox.Parent = mainFrame

local modeLabel = Instance.new("TextLabel")
modeLabel.Size = UDim2.new(1, -20, 0, 18)
modeLabel.Position = UDim2.new(0, 10, 0, 75)
modeLabel.BackgroundTransparency = 1
modeLabel.TextColor3 = Color3.fromRGB(255, 200, 0)
modeLabel.Font = Enum.Font.GothamBold
modeLabel.TextSize = 10
modeLabel.Text = "üß† LEARNING MODE: ON"
modeLabel.TextXAlignment = Enum.TextXAlignment.Left
modeLabel.Parent = mainFrame

local buttonFrame = Instance.new("Frame")
buttonFrame.Size = UDim2.new(1, -20, 0, 35)
buttonFrame.Position = UDim2.new(0, 10, 0, 98)
buttonFrame.BackgroundTransparency = 1
buttonFrame.Parent = mainFrame

local toggleButton = Instance.new("TextButton")
toggleButton.Size = UDim2.new(0.24, 0, 1, 0)
toggleButton.Position = UDim2.new(0, 0, 0, 0)
toggleButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
toggleButton.BorderColor3 = Color3.fromRGB(255, 0, 0)
toggleButton.BorderSizePixel = 2
toggleButton.TextColor3 = Color3.fromRGB(255, 0, 0)
toggleButton.Font = Enum.Font.GothamBold
toggleButton.TextSize = 11
toggleButton.Text = "OFF"
toggleButton.Parent = buttonFrame

local learnButton = Instance.new("TextButton")
learnButton.Size = UDim2.new(0.24, 0, 1, 0)
learnButton.Position = UDim2.new(0.25, 0, 0, 0)
learnButton.BackgroundColor3 = Color3.fromRGB(10, 50, 50)
learnButton.BorderColor3 = Color3.fromRGB(0, 255, 200)
learnButton.BorderSizePixel = 2
learnButton.TextColor3 = Color3.fromRGB(0, 255, 200)
learnButton.Font = Enum.Font.GothamBold
learnButton.TextSize = 11
learnButton.Text = "LEARN"
learnButton.Parent = buttonFrame

local trollButton = Instance.new("TextButton")
trollButton.Size = UDim2.new(0.24, 0, 1, 0)
trollButton.Position = UDim2.new(0.5, 0, 0, 0)
trollButton.BackgroundColor3 = Color3.fromRGB(50, 10, 50)
trollButton.BorderColor3 = Color3.fromRGB(255, 0, 255)
trollButton.BorderSizePixel = 2
trollButton.TextColor3 = Color3.fromRGB(255, 0, 255)
trollButton.Font = Enum.Font.GothamBold
trollButton.TextSize = 11
trollButton.Text = "TROLL"
trollButton.Parent = buttonFrame

local resetButton = Instance.new("TextButton")
resetButton.Size = UDim2.new(0.24, 0, 1, 0)
resetButton.Position = UDim2.new(0.75, 0, 0, 0)
resetButton.BackgroundColor3 = Color3.fromRGB(50, 50, 10)
resetButton.BorderColor3 = Color3.fromRGB(255, 255, 0)
resetButton.BorderSizePixel = 2
resetButton.TextColor3 = Color3.fromRGB(255, 255, 0)
resetButton.Font = Enum.Font.GothamBold
resetButton.TextSize = 11
resetButton.Text = "RESET"
resetButton.Parent = buttonFrame

local resultsFrame = Instance.new("ScrollingFrame")
resultsFrame.Size = UDim2.new(1, -20, 1, -195)
resultsFrame.Position = UDim2.new(0, 10, 0, 143)
resultsFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
resultsFrame.BorderColor3 = Color3.fromRGB(0, 255, 150)
resultsFrame.BorderSizePixel = 2
resultsFrame.ScrollBarThickness = 6
resultsFrame.Parent = mainFrame

local listLayout = Instance.new("UIListLayout")
listLayout.SortOrder = Enum.SortOrder.LayoutOrder
listLayout.Padding = UDim.new(0, 2)
listLayout.Parent = resultsFrame

local arrowFrame = Instance.new("Frame")
arrowFrame.Size = UDim2.new(1, -20, 0, 30)
arrowFrame.Position = UDim2.new(0, 10, 1, -35)
arrowFrame.BackgroundTransparency = 1
arrowFrame.Parent = mainFrame

local leftArrow = Instance.new("TextButton")
leftArrow.Size = UDim2.new(0.48, 0, 1, 0)
leftArrow.Position = UDim2.new(0, 0, 0, 0)
leftArrow.Text = "‚óÑ PREV"
leftArrow.Font = Enum.Font.GothamBold
leftArrow.TextSize = 14
leftArrow.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
leftArrow.TextColor3 = Color3.fromRGB(0, 255, 150)
leftArrow.BorderSizePixel = 0
leftArrow.Parent = arrowFrame

local rightArrow = Instance.new("TextButton")
rightArrow.Size = UDim2.new(0.48, 0, 1, 0)
rightArrow.Position = UDim2.new(0.52, 0, 0, 0)
rightArrow.Text = "NEXT ‚ñ∫"
rightArrow.Font = Enum.Font.GothamBold
rightArrow.TextSize = 14
rightArrow.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
rightArrow.TextColor3 = Color3.fromRGB(0, 255, 150)
rightArrow.BorderSizePixel = 0
rightArrow.Parent = arrowFrame

local function notify(message)
    pcall(function()
        StarterGui:SetCore("SendNotification", {
            Title = "Smart Search",
            Text = message,
            Duration = 2
        })
    end)
end

local function extractLetters(message)
    local pattern = "Word:%s*([A-Z][A-Z]?[A-Z]?[A-Z]?)"
    return string.match(message, pattern)
end

LogService.MessageOut:Connect(function(message, messageType)
    if string.find(message, "Word:") then
        local letters = extractLetters(message)
        if letters and consoleAutoComplete then
            lastWordTime = tick()
            table.insert(collectedLetters, letters)
            notify(letters .. " detected!")
            searchBox.Text = letters
        end
    end
end)

task.spawn(function()
    while task.wait(10) do
        if lastWordTime > 0 and tick() - lastWordTime > CONFIG.autoResetTime then
            usedWords = {}
            lastWordTime = 0
            notify("Auto-reset!")
        end
    end
end)

local function loadFromJSON(content)
    local success, wordsJson = pcall(function()
        return HttpService:JSONDecode(content)
    end)
    if not success then return false end
    for word, _ in pairs(wordsJson) do
        local len = #word
        if len >= CONFIG.minLength and len <= CONFIG.maxLength and not commonWords[word:lower()] then
            table.insert(allWords, word:lower())
        end
    end
    return true
end

local function loadFromText(content)
    for word in content:gmatch("[^\r\n]+") do
        local len = #word
        if len >= CONFIG.minLength and len <= CONFIG.maxLength and not commonWords[word:lower()] then
            table.insert(allWords, word:lower())
        end
    end
    return #allWords > 0
end

local function loadDictionary()
    notify("Loading dictionary...")
    for i, url in ipairs(DICTIONARY_URLS) do
        local ok, content = pcall(function()
            return game:HttpGet(url)
        end)
        if ok then
            local loaded = content:match("^%s*{") and loadFromJSON(content) or loadFromText(content)
            if loaded then
                searchBox.PlaceholderText = "Type word"
                loadLearningData()
                updateStatsDisplay()
                notify("Loaded " .. #allWords .. " words")
                return true
            end
        end
    end
    searchBox.PlaceholderText = "Load failed"
    notify("Failed to load")
    return false
end

local function createWordLabel(text, score)
    local lbl = Instance.new("TextButton")
    lbl.Size = UDim2.new(1, 0, 0, 28)
    lbl.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    lbl.BorderSizePixel = 0
    lbl.TextColor3 = Color3.fromRGB(0, 255, 150)
    lbl.Font = Enum.Font.Gotham
    lbl.TextSize = 15
    
    local displayText = text:upper()
    if CONFIG.learningMode and score > 0 then
        local confidence = math.min(99, math.floor(score / 10))
        displayText = displayText .. string.format(" ‚≠ê%d%%", confidence)
    end
    
    lbl.Text = displayText
    lbl.Parent = resultsFrame
    return lbl
end

local function waitForGameInput()
    local textBox = nil
    
    for _, gui in ipairs(playerGui:GetDescendants()) do
        if gui:IsA("TextBox") and gui.Visible and gui.Parent and gui.Parent.Visible then
            if gui.Name:lower():find("text") or gui.Name:lower():find("input") or gui.Name:lower():find("word") then
                textBox = gui
                break
            end
        end
    end
    
    if not textBox then
        for _, gui in ipairs(playerGui:GetDescendants()) do
            if gui:IsA("TextBox") and gui.Visible then
                textBox = gui
                break
            end
        end
    end
    
    return textBox
end

local function autoTypeWord(word, currentInput)
    if isTyping then
        notify("‚ö†Ô∏è Already typing!")
        return
    end
    
    isTyping = true
    lastTypedWord = word
    local remaining = word:sub(#currentInput + 1)
    
    task.spawn(function()
        task.wait(0.3)
        
        local targetBox = waitForGameInput()
        if not targetBox then
            notify("‚ùå Can't find input box")
            isTyping = false
            return
        end
        
        targetBox:CaptureFocus()
        task.wait(0.15)
        
        for _ = 1, 3 do
            targetBox.Text = ""
            task.wait(0.05)
        end
        
        for c in word:upper():gmatch(".") do
            targetBox.Text = targetBox.Text .. c
            task.wait(CONFIG.typingSpeed)
        end
        
        task.wait(0.2)
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
        task.wait(0.05)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
        
        task.wait(CONFIG.verificationDelay)
        
        if targetBox.Text == word:upper() or targetBox.Text ~= "" then
            recordWordFailure(word)
            updateStatsDisplay()
            notify("‚ùå " .. word .. " failed")
            targetBox.Text = ""
        else
            recordWordSuccess(word, currentInput:lower())
            updateStatsDisplay()
            notify("‚úÖ " .. word)
        end
        
        isTyping = false
        lastTypedWord = nil
    end)
end

local function displayPage()
    for _, c in ipairs(resultsFrame:GetChildren()) do
        if c:IsA("TextButton") then c:Destroy() end
    end
    local startIdx = (currentPage-1)*CONFIG.wordsPerPage + 1
    local endIdx = math.min(currentPage*CONFIG.wordsPerPage, #topWords)
    for i = startIdx, endIdx do
        local wordData = topWords[i]
        local word = wordData.word
        local score = wordData.score
        local lbl = createWordLabel(word, score)
        lbl.MouseButton1Click:Connect(function()
            if word and not isTyping then
                usedWords[word] = true
                autoTypeWord(word, searchBox.Text)
                searchBox.Text = ""
            elseif isTyping then
                notify("‚è≥ Please wait...")
            end
        end)
    end
    resultsFrame.CanvasSize = UDim2.new(0, 0, 0, listLayout.AbsoluteContentSize.Y)
end

local function updateTopWords(input)
    topWords = {}
    input = input:lower()
    if input == "" then
        for _, c in ipairs(resultsFrame:GetChildren()) do
            if c:IsA("TextButton") then c:Destroy() end
        end
        return
    end
    for _, w in ipairs(allWords) do
        if w:sub(1, #input) == input and w ~= input and not usedWords[w] then
            local score = CONFIG.learningMode and getWordScore(w, input) or 0
            table.insert(topWords, {word = w, score = score})
        end
    end
    
    if CONFIG.learningMode then
        table.sort(topWords, function(a, b)
            if a.score == b.score then
                local lenA, lenB = #a.word, #b.word
                local distA = math.abs(lenA - CONFIG.idealLength)
                local distB = math.abs(lenB - CONFIG.idealLength)
                if distA == distB then
                    return lenA == lenB and a.word < b.word or lenA < lenB
                end
                return distA < distB
            end
            return a.score > b.score
        end)
    else
        table.sort(topWords, function(a, b)
            local lenA, lenB = #a.word, #b.word
            local distA = math.abs(lenA - CONFIG.idealLength)
            local distB = math.abs(lenB - CONFIG.idealLength)
            if distA == distB then
                return lenA == lenB and a.word < b.word or lenA < lenB
            end
            return distA < distB
        end)
    end
    
    currentPage = 1
    displayPage()
end

toggleButton.MouseButton1Click:Connect(function()
    consoleAutoComplete = not consoleAutoComplete
    if consoleAutoComplete then
        toggleButton.Text = "ON"
        toggleButton.TextColor3 = Color3.fromRGB(0, 255, 0)
        toggleButton.BorderColor3 = Color3.fromRGB(0, 255, 0)
        notify("Console enabled")
    else
        toggleButton.Text = "OFF"
        toggleButton.TextColor3 = Color3.fromRGB(255, 0, 0)
        toggleButton.BorderColor3 = Color3.fromRGB(255, 0, 0)
        notify("Console disabled")
    end
end)

learnButton.MouseButton1Click:Connect(function()
    CONFIG.learningMode = not CONFIG.learningMode
    if CONFIG.learningMode then
        learnButton.Text = "LEARN"
        learnButton.TextColor3 = Color3.fromRGB(0, 255, 200)
        learnButton.BorderColor3 = Color3.fromRGB(0, 255, 200)
        modeLabel.Text = "üß† LEARNING MODE: ON"
        notify("üß† Learning enabled")
    else
        learnButton.Text = "BASIC"
        learnButton.TextColor3 = Color3.fromRGB(150, 150, 150)
        learnButton.BorderColor3 = Color3.fromRGB(100, 100, 100)
        modeLabel.Text = "üìù BASIC MODE"
        notify("Basic mode")
    end
    updateTopWords(searchBox.Text)
end)

trollButton.MouseButton1Click:Connect(function()
    if isTyping then
        notify("‚è≥ Please wait...")
        return
    end
    if searchBox.Text == "" then
        notify("Type letters first!")
        return
    end
    local input = searchBox.Text:lower()
    local longWords = {}
    for _, w in ipairs(allWords) do
        if w:sub(1, #input) == input and not usedWords[w] and #w >= 7 then
            table.insert(longWords, w)
        end
    end
    if #longWords == 0 then
        notify("No long words!")
        return
    end
    table.sort(longWords, function(a, b) return #a > #b end)
    local trollWord = longWords[1]
    usedWords[trollWord] = true
    notify("üòà TROLL: " .. trollWord:upper())
    autoTypeWord(trollWord, searchBox.Text)
    searchBox.Text = ""
end)

resetButton.MouseButton1Click:Connect(function()
    usedWords = {}
    lastWordTime = 0
    notify("Reset complete!")
end)

leftArrow.MouseButton1Click:Connect(function()
    if currentPage > 1 then
        currentPage = currentPage - 1
        displayPage()
    end
end)

rightArrow.MouseButton1Click:Connect(function()
    if currentPage < math.ceil(#topWords/CONFIG.wordsPerPage) then
        currentPage = currentPage + 1
        displayPage()
    end
end)

searchBox.Focused:Connect(function()
    searchBox.Text = ""
end)

searchBox:GetPropertyChangedSignal("Text"):Connect(function()
    updateTopWords(searchBox.Text)
end)

task.spawn(function()
    if loadDictionary() then
        notify("üß† Smart mode ready!")
    end
end)
